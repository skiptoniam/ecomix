block_circulant_basis <- function (x, y, sig2, rho, nu=1/2) {
  # get a the basis vector for a block-circulant matrix representing the
  # dispersal matrix between equally-spaced grid cells on a torus, as some
  # function `f` of euclidean distance. `x` and `y` are vectors containing
  # equally-spaced vectors for the x and y coordinates of the grid cells on a
  # plane (i.e. the real coordinates). These should have been extended in order
  # to approximate some centre portion as a 2D plane.

  # number and dimension of grid cells
  m <- length(x)
  n <- length(y)
  x_size <- x[2] - x[1]
  y_size <- y[2] - y[1]

  # create indices for x and y on the first row of the dispersal matrix
  xidx <- rep(1:m, n)
  yidx <- rep(1:n, each = m)

  # project onto the torus and get distances from the first cell, in each
  # dimension
  xdist <- abs(xidx - xidx[1])
  ydist <- abs(yidx - yidx[1])
  xdist <- pmin(xdist, m - xdist) * x_size
  ydist <- pmin(ydist, n - ydist) * y_size

  # flatten distances into Euclidean space, apply the dispersal function and
  d <- sqrt(xdist ^ 2 + ydist ^ 2)

  ##
  cf <- covariance_function(d, sig2, rho, nu)

  #return
  return(cf)
}

covariance_function <- function(d, sig2, rho, nu=1/2){

  if(!nu%in%c(1/2,3/2,5/2))
    stop("nu must be one one of 1/2, 3/2 or 5/2")

  #calculate the covariance
  if( nu == 1/2)
    covvy1 <- sig2 * exp( -d/rho)
  if( nu == 3/2)
    covvy1 <- sig2 * (1+sqrt(3)*d/rho) * exp( -sqrt(3)*d/rho)
  if( nu == 5/2)
    covvy1 <- sig2 * (1+sqrt(5)*d/rho+5*(d^2)/(3*(rho^2))) * exp( -sqrt(5)*d/rho)

  return(covvy1)
}

extend <- function (x, factor = 2) {
  # given an evenly-spaced vector `x` of cell center locations, extend it to the
  # shortest possible vector that is at least `factor` times longer, has a
  # length that is a power of 2 and nests the vector `x` approximately in the
  # middle. This is used to define each dimension of a grid mapped on a torus
  # for which the original vector x is approximately a plane.

  # get cell number and width
  n <- length(x)
  width <- x[2] - x[1]

  # the smallest integer greater than or equal to than n * factor and an
  # integer power of 2
  n2 <- 2 ^ ceiling(log2(factor * n))

  # find how much to pad each end of n
  pad <- n2 - n
  if (pad %% 2 == 0) {
    # if it's even then that's just tickety boo
    pad1 <- pad2 <- pad / 2
  } else {
    # otherwise put the spare cell on the right hand side
    pad1 <- (pad - 1) / 2
    pad2 <- (pad + 1) / 2
  }

  # define the padding vectors
  padx1 <- x[1] - rev(seq_len(pad1)) * width
  padx2 <- x[n] + seq_len(pad2) * width

  # combine these and add an attribute returning the start and end indices for
  # the true vector
  newx <- c(padx1, x, padx2)
  attr(newx, 'idx') <- pad1 + c(1, n)
  newx
}

seq_range <- function (range, by = 1) seq(range[1], range[2], by = by)

setupFFTgp <- function (x, y, factor = 2,  sig2 = 0.5, rho=0.1, nu=1/2) {

  # extend the vectors (to project our plane on <= 1/4 of a torus)
  xe <- extend(x, factor)
  ye <- extend(y, factor)

  # get indices to true vectors
  xidx <- seq_range(attr(xe, 'idx'))
  yidx <- seq_range(attr(ye, 'idx'))

  # get fft basis for covariance on a torus
  bcb_vec <- block_circulant_basis(ye, xe, sig2, rho, nu)
  ## Sanity check
  # image(matrix(bcb_vec,length(ye),length(xe)))

  # create an empty covariance on all grid cells of the torus
  cov_torus <- matrix(0, length(ye), length(xe))

  # return as a named list for use in each iteration
  list(bcb_vec = bcb_vec,
       cov_torus = cov_torus,
       xidx = xidx,
       yidx = yidx)
}

fft_GP <- function(meanmat,fs){

  # duplicate meanmat to create 'before' condition
  meanmat_orig <- meanmat
  missing <- is.na(meanmat)

  # check for missing values and replace with zeros
  if (any(missing)) {
    meanmat[missing] <- 0
  }

  # insert mean of the covariance function in to the torus
  fs$cov_torus[fs$yidx, fs$xidx] <- meanmat

  cov_fft <- stats::fft(t(fs$cov_torus))
  bcb_fft <- stats::fft(fs$bcb_vec)
  cov_new_torus_fft <- stats::fft(cov_fft * bcb_fft, inverse = TRUE)

  # convert back to real domain, apply correction and transpose
  cov_torus_new <- t(Re(cov_new_torus_fft) / length(fs$cov_torus))
  cov_new <- cov_torus_new[fs$yidx, fs$xidx]

  # return NA values to matrix
  cov_new[missing] <- NA

  return(cov_new)

}

#'@title Simulate a gaussian markov random field
#'@name rGMRF
#'@description simulate a Gaussian Markov Random Field from the Matern family.
#'This is developed from the Rue & Held 2005 Algorithim 2.10.
#'@param x vector of evenly spaced values in the x-direction
#'@param y vector of evenly spaced values in the y-direction (default is the same as x)
#'@param sig2 gives the marginal variance of the process
#'@param rho is effective range/lengthscale
#'@param nu is smoothness for the Matern, can be either 1/2, 3/2, 5/2 if none of these then an error will be thrown.
#'@param nugget is nugget variance. Default is NULL.
#'@export
#'@examples
#' # exponential with no nugget
#' x <- y <- seq(-2, 2, len=250)
#' covsim1 <- rGMRF(x,y, sig2 = 10,rho = .5, nu = 1/2)
#' image(x,y,covsim1)

#'# 3/2 Matern with nugget
#' x <- y <- seq(-2, 2, len=250)
#' covsim2 <- rGMRF(x,y,sig2 = .1,rho = .5, nu = 3/2, nugget = 1.5^2)
#' image(x,y,covsim2)

rGMRF <- function(x, y = x, sig2 = 1, rho = 0.5, nu = 1/2, nugget = NULL){

  fs <- setupFFTgp(x = x, y = y, factor = 2, sig2 = sig2, rho = rho, nu = nu)

  nx <- length(x)
  ny <- length(y)

  meanmat <- matrix(rnorm(nx*ny,mean = 0,sd = 1),nx,ny)

  sim <- fft_GP(meanmat = meanmat, fs = fs)

  if(!is.null(nugget))
    sim <- sim + rnorm(nx*ny,mean = 0,sd = sqrt(nugget))

  return(sim)

}
