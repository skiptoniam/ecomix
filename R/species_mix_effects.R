#' Generate data for plotting or predicting partial effects of covariates
#'
#' This function produces a list of data.frames for predicting the partial
#' effect of a focal.predictor current included in a species_mix model.
#'
#' @title Generate data for plotting or predicting partial effects of covariates
#' @name effect_data
#' @description This function produces a list of data.frames for predicting the partial
#' effect of a focal.predictor current included in a species_mix model.
#' @return This function should return a list of data.frames one for each focal.predictor.
#' This will enable user to predict marginal effects or plot the partial response plots.
#' @param focal.predictors A character or string of characters which represent covariates in the model.
#' @param mod The fitted species_mix model.
#' @param ngrid The length of the prediction vector.
#' @param ... other arguments
#' @examples
#'\donttest{
#' library(ecomix)
#' set.seed(42)
#' sam_form <- stats::as.formula(paste0('cbind(',paste(paste0('spp',1:20),
#' collapse = ','),")~x1+x2"))
#' sp_form <- ~ 1
#' beta <- matrix(c(-2.9,-3.6,-0.9,1,.9,1.9),3,2,byrow=TRUE)
#' dat <- data.frame(y=rep(1,100),x1=stats::runif(100,0,2.5),
#' x2=stats::rnorm(100,0,2.5))
#' dat[,-1] <- scale(dat[,-1])
#' simulated_data <- species_mix.simulate(archetype_formula = sam_form,species_formula = sp_form,
#' data = dat,beta=beta,family="bernoulli")
#' fm1 <- species_mix(archetype_formula = sam_form,species_formula = sp_form,
#' data = simulated_data, family = 'bernoulli',  nArchetypes=3)
#' effects_data("x1",fm1)
#'}
#' @rdname effects_data
#' @export effects_data
"effects_data" <- function (focal.predictors, mod, ...){
  UseMethod("effects_data", mod)
}

#' @export
"effects_data.species_mix" <- function(focal.predictors, mod, ngrid = 50, ...){

  if (is.null(mod$titbits))
    stop("Model doesn't contain all information required for effectsPlotData.
         Please supply model with titbits (from titbits=TRUE in species_mix call)")

  Mode <- function(x, na.rm = FALSE) {
    if (na.rm) {
      x = x[!is.na(x)]
    }
    ux <- unique(x)
    return(ux[which.max(tabulate(match(x, ux)))])
  }

  ## set up the data objects
  X <- mod$titbits$X
  W <- mod$titbits$W
  U <- mod$titbits$U

  ## set up the variables in the formula
  tt <- terms(mod$titbits$archetype_formula)
  tt <- delete.response(tt)
  vars <- all.vars(parse(text=tt))
  if(ncol(W)>1){
    tt2 <- terms(mod$titbits$species_formula)
    vars <- c(vars,all.vars(parse(text=tt2)))
  }
  if(!is.null(U)){
    tt3 <- terms(mod$titbits$all_formula)
    vars <- c(vars,all.vars(parse(text=tt3)))
  }

  nvars = length(vars)

  pred.data <- mod$titbits$data
  pred.data <- pred.data[,vars]

  ## check for factors
  factors <- NULL
  for(ii in 1:nvars){
    factors[ii] <- is.factor(pred.data[,vars[ii]])
  }

  ## check for focal.predictors in pred.data
  focal.ids <- lapply(focal.predictors, grep, colnames(pred.data))

  # lists for data structures
  mfs <- list() #catch model.frames
  f.focal <- list()
  v.focal <- list()
  n.focal <- list()
  for(i in 1:length(focal.ids)){

    f.focal[[i]] <- factors[focal.ids[[i]]]
    if(any(f.focal[[i]])) v.focal[[i]] <- pred.data[, focal.ids[[i]]]
    else v.focal[[i]] <- pred.data[, focal.ids[[i]],drop=FALSE]
    n.focal[[i]] <- seq_len(nvars)[-unlist(focal.ids[[i]])]

    xx <- list()
    for(j in 1:length(focal.ids[[i]])){
      if(f.focal[[i]][j]) {
        xx[[j]] = levels(v.focal[[i]][j])
        ngrid = length(xx)
      } else {
        mi = min(v.focal[[i]][j])
        ma = max(v.focal[[i]][j])
        xx[[j]] = seq(mi, ma, length.out = ngrid)
      }
    }
    XDataNew = data.frame(xx, stringsAsFactors = TRUE)
    colnames(XDataNew) = vars[focal.ids[[i]]]
    for (k in seq_len(length(n.focal[[i]]))) {
      non.focal = n.focal[[i]][k]
      f.non.focal = factors[non.focal]
      v.non.focal = pred.data[, vars[non.focal]]
      if (f.non.focal) {
        XDataNew[, vars[non.focal]] = Mode(v.non.focal)
      }
      if (!f.non.focal) {
        v.non.focal = pred.data[, vars[non.focal]]
        XDataNew[, vars[non.focal]] = mean(v.non.focal)
      }
    }
    mfs[[i]] <- XDataNew[,vars]
  }

  names(mfs) <- focal.predictors
  class(mfs) <- "species_mix_effects_data"

  return(mfs)

}

#' @rdname plot.species_mix_effects_data
#' @name plot.species_mix_effects_data
#' @title plot.species_mix_effects_data
#' @param x a list of partial prediction data frames as generated by
#' effects_data
#' @param object A fitted species_mix model.
#' @param object2 A species_mix.bootsrap object. Default is NULL, no standard
#' errors will be reported.
#' @param nboot An option to do bootstrapping when plotting, this will be slow,
#' better to run and save bootstrap object and pass to plotting function as
#' object2.
#' @param type The type of prediction. Default is 'response' alternative is 'link'.
#' @param response.var What response variable to plot on the y-axis. Default is
#' all Archetypes. Other options are a subset of Archetypes, names "Archetype1".
#' Or species can be plotted, "Species" will plot all species predictions in the
#' model. "SpeciesSum" with sum all species predictions on the y-axis, for a
#' binomial model this will represent species richness. For other models, it will
#' be the sum of the species specific responses. Finally, individual species can
#' be plotted using the species name in the original response data.
#' @param CI is the confidence intervals for the stand errors.
#' @param linecols Are the default colours for plotting the partial responses.
#' @param polycols Is the colour of the confidence intervals in the response plots.
#' @param ylim Default is NULL and will plot ylim within range of the response variable.
#' @param \\dots Extra plotting arguments.
#' @details Plots the partial dependence plots (marginal response curves) for
#' focal covariates. Continuous covariates will be plotted as lines, factors
#' will be plotted as dotplots.
#' @importFrom abind adrop
#' @importFrom stats .checkMFClasses delete.response formula terms
#' @importFrom graphics axis
#' @importFrom utils stack
#' @export
#' @examples
#'\donttest{
#' library(ecomix)
#' set.seed(42)
#' sam_form <- stats::as.formula(paste0('cbind(',paste(paste0('spp',1:20),
#' collapse = ','),")~x1+z1"))
#' sp_form <- ~ 1
#' beta <- matrix(c(-2.9,-3.6,-0.9,1,.9,1.9),3,2,byrow=TRUE)
#' dat <- data.frame(y=rep(1,100),x1=stats::runif(100,0,2.5),
#' z1=stats::rnorm(100,0,2.5))
#' dat[,-1] <- scale(dat[,-1])
#' simulated_data <- species_mix.simulate(archetype_formula = sam_form,species_formula = sp_form,
#' data = dat,beta=beta,family="bernoulli")
#' fm1 <- species_mix(archetype_formula = sam_form,species_formula = sp_form,
#' data = simulated_data, family = 'bernoulli',  nArchetypes=3)
#' eff.df <- effects_data("x1",fm1)
#' plot(eff.df,fm1)
#'}
"plot.species_mix_effects_data" <- function(x, object, object2 = NULL,
                                              nboot = 0,
                                              type='response',
                                              response.var = NULL,
                                              CI = c(0.025, 0.975),
                                              linecols = c("#1B9E77","#D95F02","#7570B3",
                                                           "#E7298A","#66A61E","#E6AB02",
                                                           "#A6761D","#666666"),
                                              polycols = "#00000020", ylim=NULL, ...){

  if(is.null(response.var)) response.var <- "Archetypes"
  if(any(!response.var%in%"Archetypes"))  if( ! all( response.var %in% c("Species","SpeciesSum",object$names$spp,object$names$SAMs)))
    stop( "Unknown measure.  Options are 'Species', 'SpeciesSum', 'Archetypes',\nany
    one of the species names as supplied (stored in object$names$spp) or a specific Archetype (stored in object$names$SAMs)")

  if(any(response.var%in%c(object$names$SAMs,"Archetypes"))) typePred <- "archetype"
  if(any(response.var%in%c(object$names$spp,"Species","SpeciesSum"))) typePred <- "species"

  ## function to add a random row to deal with poly degree error.
  add_row <- function(x, degree = 2){

    factors <- NULL
    for( i in 1:ncol(x)){
      factors[i] <- is.factor(x[,i])
    }

    x[nrow(x) + 1:degree ,factors] <- unique(x[nrow(x),factors])
    x[nrow(x) + ((1:degree)-degree) ,!factors] <- rnorm(ncol(x[nrow(x),!factors])*degree,sd=1e-6)

    return(x)

  }

  xnew <- lapply(x,add_row)



  partial.preds <- suppressMessages(lapply(xnew, function(ii) predict(object=object, object2=object2,
                                                                      newdata = ii, offset = NULL,
                                                                      nboot = nboot, alpha=CI[2]-CI[1],
                                                                      prediction.type = typePred, type=type)))

  ## remove the dummy columns
  remove_dummy_rows <- function(x, partial.preds){

    nrow.orig <- nrow(x)

    if(length(partial.preds)==4){
      partial.preds$ptPreds <- partial.preds$ptPreds[1:nrow.orig, ,drop=FALSE]
      partial.preds$bootPreds <- partial.preds$bootPreds[1:nrow.orig, ,drop=FALSE]
      partial.preds$bootSEs <- partial.preds$bootSEs[1:nrow.orig, ,drop=FALSE]
      partial.preds$bootCIs <- partial.preds$bootCIs[1:nrow.orig, , , drop=FALSE]
    } else {
      partial.preds <- partial.preds[1:nrow.orig, ,drop=FALSE]
    }


    return(partial.preds)

  }

  partial.preds <- lapply(1:length(x),function(ii)remove_dummy_rows(x[[ii]],partial.preds[[ii]]))
  names(partial.preds) <- names(x)


  if(object$disty%in%c(1,7))ylabel <- "Probability"
  if(object$disty%in%c(2,4))ylabel <- "Count"
  # if(object$disty%in%c(3))ylabel <- "Intensity"
  if(object$disty%in%c(5))ylabel <- "Biomass"
  if(object$disty%in%c(6))ylabel <- "y"

  for (i in seq_len(length(partial.preds))){

    se.plots <- FALSE
    if(length(partial.preds[[i]])==4) se.plots <- TRUE

    if( any(response.var %in% object$names$spp)){
      idx <- which(object$names$spp %in% response.var)
    } else if ( any(response.var %in% object$names$SAMs)){
      idx <- which(object$names$SAMs %in% response.var)
    } else {
      if(se.plots)idx <- seq(1,ncol(partial.preds[[i]][[1]]))
      else idx <- seq(1,ncol(partial.preds[[i]]))
    }

    sppColidx <- apply(object$tau[idx,],1,which.max)

    xlabel <- names(x[i])
    xx <- x[[i]][,names(x[i])]
    fac.var <- is.factor(xx)

    if(se.plots){

      yy.mn <- partial.preds[[i]]$bootPreds[,idx,drop=FALSE]
      yy.lwr <- abind::adrop(partial.preds[[i]]$bootCIs[,idx,1,drop=FALSE],drop=3)
      yy.upp <- abind::adrop(partial.preds[[i]]$bootCIs[,idx,2,drop=FALSE],drop=3)

      if(any(response.var%in%"SpeciesSum")){
        yy.mn <- matrix(rowSums(partial.preds[[i]]$ptPreds[,idx,drop=FALSE]),ncol=1)
        yy.lwr <-  matrix(rowSums(partial.preds[[i]]$bootCIs[,idx,1,drop=FALSE]),ncol=1)
        yy.upp <-  matrix(rowSums(partial.preds[[i]]$bootCIs[,idx,2,drop=FALSE]),ncol=1)

        idx <- 1
        ylabel <- NULL
        if (is.null(ylabel)) {
          ylabel = "Summed response"
          if (any(object$disty %in% c(1,7))) {
            ylabel = "Species Richness"
          }
          if (any(object$disty %in% c(2,3,4))) {
            ylabel = "Total Count"
          }
          if (any(object$disty %in% c(5))) {
            ylabel = "Total Biomass"
          }
        }
      }

      lo1 <- min(yy.lwr)
      hi1 <- max(yy.upp)

      if(is.null(ylim)) ylimy <- c(lo1,hi1)
      else ylimy <- ylim

      cols <- linecols
      cols <- rep(cols,100)

      if(!is.factor(xx)){
        matplot(xx, yy.mn, ylim = ylimy,
                type = "l",
                xaxt = "n", xlab = xlabel, ylab = ylabel)
        axis(1, c(min(xx), (min(xx) + max(xx))/2, max(xx)),round(c(min(xx), (min(xx) + max(xx))/2, max(xx)),2))# c("min", "mean", "max"))
        for(j in 1:ncol(yy.lwr)){
          polygon(c(xx, rev(xx)), c(yy.lwr[,j], rev(yy.upp[,j])),
                  col = polycols, border = FALSE)
          if(length(idx)<9)
            lines(xx, yy.mn[,j], col=cols[j],  lwd = 2)
          else
            lines(xx, yy.mn[,j], col=cols[sppColidx[j]],  lwd = 1)
        }
        if(all(length(idx)<9 & !response.var%in%"SpeciesSum"))
          legend(x="topleft",
                 legend=dimnames(yy.mn)[[2]],
                 col=cols[1:length(dimnames(yy.mn)[[2]])],
                 lty=1,
                 cex=0.9,
                 bty="n")
        # title(main = xlabel)

      } else {
        params <- cbind(xx,
                        utils::stack(as.data.frame(yy.mn))[,2:1],
                        utils::stack(as.data.frame(yy.lwr))[,1],
                        utils::stack(as.data.frame(yy.upp))[,1])
        colnames(params) <- c("ftr","grp","mean","lower","upper")

        if(is.null(ylim)) ylimy <- range(c(params$lower,params$upper))+c(-0.02,0.02)
        else ylimy <- ylim

        # background for a forest plot
        axis.locs <- seq(.5,by=.5,length.out=length(unique(params$ftr)))
        locs <- rep(axis.locs,each= length(unique(params$grp)))+seq(-0.05,0.05,length.out = length(unique(params$grp)))
        plot(mean~locs,
             data = params,
             type = "n",
             xlab = xlabel,
             ylab = ylabel,
             axes = FALSE,
             bty = "n",
             xlim = c(0.25, (max(axis.locs)+.25)),
             ylim = ylimy)
        axis(side = 2, tcl = -0.3)
        axis(side = 1, lty = 0, at = axis.locs, labels = unique(params$ftr), las = 1, col.lab = grey(0.3))

        for (i in seq_len(nrow(params))) {
          lines(y = c(params$lower[i], params$upper[i]),
                x = cbind(locs[i], locs[i]),
                lwd = 4,
                col = linecols[as.numeric(rep(unique(params$grp),length(unique(params$ftr)))[i])])
        }

        points(params$mean~locs,
               pch = 16,
               cex  = 1.5,
               col = linecols[as.numeric(rep(unique(params$grp),length(unique(params$ftr))))])

        if(all(length(idx)<9 & !response.var%in%"SpeciesSum"))
          legend(x="topleft",
                 legend=unique(params$grp),
                 col= linecols[as.numeric(unique(params$grp))],
                 pch=16,
                 cex=0.9,
                 bty="n")

        # title(main = xlabel)

      }

    } else {

      yy.mn <- partial.preds[[i]][,idx,drop=FALSE]

      if(any(response.var%in%"SpeciesSum")){
        yy.mn <- matrix(rowSums(partial.preds[[i]][,idx,drop=FALSE]),ncol=1)
        idx <- 1
        ylabel <- NULL
        if (is.null(ylabel)) {
          ylabel = "Summed response"
          if (any(object$disty %in% c(1,7))) {
            ylabel = "Species Richness"
          }
          if (any(object$disty %in% c(2,3,4))) {
            ylabel = "Total Count"
          }
          if (any(object$disty %in% c(5))) {
            ylabel = "Total Biomass"
          }
        }
      }

      lo1 <- min(yy.mn)
      hi1 <- max(yy.mn)

      cols <- linecols
      cols <- rep(cols,100)

      if(is.null(ylim)) ylimy <- c(lo1,hi1)
      else ylimy <- ylim

      if(!fac.var){
        matplot(xx, yy.mn, ylim = ylimy,
                type = "l", xaxt = "n", xlab = xlabel, ylab = ylabel)
        axis(1, c(min(xx), (min(xx) + max(xx))/2, max(xx)),round(c(min(xx), (min(xx) + max(xx))/2, max(xx)),2))# c("min", "mean", "max"))
        for(j in 1:ncol(yy.mn)){
          if(length(idx)<9)
            lines(xx, yy.mn[,j], col=cols[j],  lwd = 2)
          else
            lines(xx, yy.mn[,j], col=cols[sppColidx[j]],  lwd = 1)

        }
        if(all(length(idx)<9 & !response.var%in%"SpeciesSum"))
          legend(x="topleft",
                 legend=dimnames(yy.mn)[[2]],
                 col=cols[1:length(dimnames(yy.mn)[[2]])],
                 lty=1,
                 cex=0.9,
                 bty="n")

        # title(main = xlabel)

      } else {
        params <- cbind(xx, utils::stack(as.data.frame(yy.mn))[,2:1])
        colnames(params) <- c("ftr","grp","mean")

        if(is.null(ylim)) ylimy <- range(c(params$mean))+c(-0.02,0.02)
        else ylimy <- ylim

        axis.locs <- seq(.5,by=.5,length.out=length(unique(params$ftr)))
        locs <- rep(axis.locs,each= length(unique(params$grp)))+seq(-0.05,0.05,length.out = length(unique(params$grp)))
        plot(mean~locs,
             data = params,
             type = "n",
             xlab = xlabel,
             ylab = ylabel,
             axes = FALSE,
             bty = "n",
             xlim = c(0.25, (max(axis.locs)+.25)),
             ylim = ylimy)
        axis(side = 2, tcl = -0.3)
        axis(side = 1, lty = 0, at = axis.locs, labels = unique(params$ftr), las = 1, col.lab = grey(0.3))

        points(params$mean~locs,
               pch = 16,
               cex  =1.5,
               col = linecols[as.numeric(rep(unique(params$grp),length(unique(params$ftr))))])

        if(all(length(idx)<9 & !response.var%in%"SpeciesSum"))
          legend(x="topleft",
                 legend=unique(params$grp),
                 col= linecols[as.numeric(unique(params$grp))],
                 pch=16,
                 cex=0.9,
                 bty="n")

        # title(main = xlabel)


      }
    }
  }

}

