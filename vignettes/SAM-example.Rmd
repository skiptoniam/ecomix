---
title: "Species Archetype Model Example"
output: rmarkdown::html_vignette
csl: mee.csl
bibliography: ecomix_app.bib
vignette: >
  %\VignetteIndexEntry{Species Archetype Model Example}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  cache = FALSE
)
```

### Species Archetype Models
The Species Archetype Models (SAMs) are variant of 'Mixture-of-Regressions' and try to describe how homogeneous groups of **species** vary with the environment. These groups are referred to as Species Archetypes [@dunstan_model_2011]. Each Archetype represents a group of species which jointly response to environmental data in the model (covariates). For example, one group of species might like warm water, while another might like cold. Typically, we model observations of species at sites. The covariates are used to describe the variation (and response) of each Archetype to the physical and environmental gradients. We can describe the data as $i = 1...n$ sampling sites, $j = 1...S$ species (or desired taxonomic unit) and $k = 1...K$ Archetypes. The model conditional mean observations (occurrence/count/biomass) of species is, $\mathbb{E}(y_{ij}|\textrm{archetype group_k})$, on $g_k(X_i)$ Archetype covariates. In `ecomix`, the intercepts are species-specific, this is an update from the original 'SpeciesMix' R package [@dunstan_speciesmix_2013], where the intercepts were only species-specific for the Negative Binomial and Tweedie distributions, as described in @dunstan_finite_2013. For error distributions with dispersion or variance parameters (Negative Binomial, Tweedie and Gaussian) these parameters are also species-specific. The model can be described as follows:

$$
\begin{equation}
h[\mathbb{E}(y_{ij}|\phi_{k})] = \alpha_j + g_k(X_{i}^\top\beta_{k}) + \nu_i \tag{1}\label{eq:one}
\end{equation}
$$

where $Pr(\phi_{k}) = \pi_k,$ and $\sum^K_{k=1}{\pi_k=1}$. The functional form of $g_k(.)$ can be specified to be any function commonly used within a Generalized Linear Model framework. Including linear, quadratic, spline and interaction terms. Additionally an offset term $\nu_i$ can be included to account for sampling artefacts and are included into the model on a log-scale (e.g. log(area sampled)). We refer to the model as the `species_mix` in the `ecomix` package. 

```{r setup}
library(ecomix)
```

Here we will demonstrate how to fit and interpret a Species Archetype Models (SAMs) from our `ecomix` package. We will present a simulation study to demonstrate the functionality of `species_mix`.

#### Simulate Environmental Data 
We generate a set of simulated environment predictors using Gaussian random fields with nugget effects on some of the variables. 

```{r,echo=TRUE,eval=TRUE,warning=FALSE,message=FALSE}
library(raster)
library(reshape2)
library(ggplot2)
library(grid)
library(gridExtra)
library(RandomFields)
set.seed(007)
lenny <- 100
xSeq <- seq( from=0, to=1, length=lenny)
ySeq <- seq( from=0, to=1, length=lenny)
X <- expand.grid( x=xSeq, y=ySeq)
Mod1 <- RMgauss( var=1, scale=0.2) + RMnugget( var=0.01)
Mod2 <- RMgauss( var=1, scale=0.5) + RMnugget( var=0.01)
Mod3 <- RMgauss( var=1, scale=1)# + RMnugget( var=0.01)
Mod4 <- RMgauss( var=2, scale=0.1) + RMnugget( var=1)
simmy1 <- RFsimulate( Mod1, x=xSeq, y=ySeq)
simmy2 <- RFsimulate( Mod2, x=xSeq, y=ySeq)
simmy3 <- RFsimulate( Mod3, x=xSeq, y=ySeq)
simmy4 <- RFsimulate( Mod4, x=xSeq, y=ySeq)
X <- cbind( X, as.numeric( as.matrix( simmy1)), as.numeric( as.matrix( simmy2)),
            as.numeric( as.matrix( simmy3)), as.numeric( as.matrix( simmy4)))
X[,-(1:2)] <- apply( X[,-(1:2)], 2, scale)
colnames( X) <- c("x","y","covar1","covar2","covar3","covar4")
env <- rasterFromXYZ( X)
names(env) <- c("Temperature", "Oxygen", "Depth", "Productivity")
env.df <- as.data.frame(env,xy=TRUE)
env_dat<-rasterToPoints(env)
```

```{r env plots, fig.width= 4, fig.height= 4, fig.cap="Figure 1. Simulated environmental variables used in Species Archetype Modelling", echo=FALSE}
# matrix form
p2a <- ggplot() +
  geom_raster(data =  env.df, 
              aes(x = x, y = y, 
                  fill = Temperature)) + 
  scale_fill_viridis_c(option = "B")+
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position = "none") +
    scale_x_continuous(expand=c(0, 0)) + 
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('Temperature')+coord_fixed()

p2b <- ggplot() +
  geom_raster(data =  env.df, 
              aes(x = x, y = y, 
                  fill = Oxygen)) + 
  scale_fill_viridis_c(option = "C")+
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position = "none") +
    scale_x_continuous(expand=c(0, 0)) + 
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('Oxygen')+coord_fixed()

p2c <- ggplot() +
  geom_raster(data =  env.df, 
              aes(x = x, y = y, 
                  fill = Depth)) + 
  scale_fill_viridis_c(option = "E")+
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position = "none") +
    scale_x_continuous(expand=c(0, 0)) + 
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('Depth')+coord_fixed()

p2d <- ggplot() +
  geom_raster(data =  env.df, 
              aes(x = x, y = y, 
                  fill = Productivity)) + 
  scale_fill_viridis_c()+
  theme(axis.title.x = element_blank(), 
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position = "none") +
    scale_x_continuous(expand=c(0, 0)) + 
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('Productivity')+coord_fixed()
  
grid.arrange(p2a, p2b, p2c, p2d, nrow = 2)
```

#### Simulate Biological Data
We simulated a set of synthetic species to be fitted using the `species_mix` function. We generated the expected species intercepts $\alpha_j$ from a beta distribution, and assign known group level covariates $\beta_k$. $\beta_k$ represents the archetype (group) response to each covariate in the model. We simulated species archetypical responses using the `species_mix.simulate` function. If no known parameters are provided random parameters will be generated for the formula and data provided. Here we provided parameters for the species intercepts (alphas) and the archetype mean responses (betas). 

```{r, eval=TRUE, echo=TRUE}
set.seed(42)
nsp <- 100
betamean <- 0.3
betabeta <- 2
betaalpha <- betamean/(1-betamean) 
alpha <- rbeta( nsp, betaalpha, betabeta) 
alphas <- log( alpha / ( 1-alpha))  

betas <- as.matrix(data.frame(Temperature=c(0.75,0,1.5),
                              Temperature2=c(-0.75,0,0),
                              Oxygen=c(0,0.5,0),
                              Oxygen2=c(0,-0.5,0),
                              Depth= c(-1.5,0.5,1.5),
                              Depth2= c(0,-0.5,0),
                              Productivity=c(1,0,-2.5),
                              Productivity2=c(-1,0,0),
                              Time=rnorm(3)))
rownames(betas) <- paste0("Archetype.",1:3)

# generate realisation of data for entire survey region
sim_dat <- data.frame(intercept=1,env_dat[,3:ncol(env_dat)])
sites<-sample(1:nrow(sim_dat), 200, replace=FALSE)
env_200<-sim_dat[sites,]
env_200$Time <- sample(c(0,1),size = 200, replace = TRUE)

sam_form <- stats::as.formula(paste0('cbind(',paste(paste0('spp',1:100),
collapse = ','),")~poly(Temperature,degree=2,raw=TRUE)+poly(Oxygen,degree=2,raw=TRUE)+poly(Depth,degree=2,raw=TRUE)+poly(Productivity,degree=2,raw=TRUE)+Time"))
sp_form <- ~1
simulated_data200 <- species_mix.simulate(archetype_formula=sam_form,
                                       species_formula=sp_form,
                                       alpha = alphas,
                                       beta = betas,
                                       data = env_200,
                                       nArchetypes = 3,
                                       family = "bernoulli")
```

```{r, echo=TRUE, fig.cap='Figure 2. The simulated occurrences for the 100 species. We will remove all species with less than 10 presences across all 200 sites. '}
library(ggplot2)
df1 <- data.frame(occ=colSums(simulated_data200[,1:100]))
p2a <- ggplot(df1)+
  geom_histogram(aes(x=occ),bins = length(unique(colSums(simulated_data200[,1:100]))))+
          geom_vline(xintercept = 10,colour='red')+
        ylab("Count of Species")+
        xlab("Number of Species's Occurrences")+
        ggtitle("a)")
p2a  
```

#### Model fitting and evaluation
We have generated occurrence records for 100 synthetic species across the 200 randomly surveyed sites. Because we have presence and absence data we can fit a SAM with a Bernoulli family. In this example, we may chose to remove the rare species (< 10 occurrences across all sites). These species could be potentially included in the model, but would likely create noise and unexplained variance, making the model harder to fit and estimate [@hui_mix_2013].    

In this, example we fit linear parameters for the five simulated covariates Temperature, Oxygen, Depth, Productivity & Time. We do this to demonstrate a simple simulated example where can show the known response of covariates to simulated data. We include time as a factor, which represents the time in which the simulated sample was recorded, for these data the two factors are 'Day' or 'Night'. 

Below is a small code block with a basic example on how to fit a single species_mix model. 
```{r, echo=TRUE, eval=TRUE,message=FALSE,warning=FALSE}
## load the ecomix package
library(ecomix)
 
## Select species with greater than ten occurrences across all sites.
spdata <- simulated_data200[,1:100] 
spdata <- spdata[,-which(colSums(simulated_data200[,1:100])<10)] 
samdat_10p <- cbind(spdata,env_200)
samdat_10p$Time <- as.factor(ifelse(samdat_10p$Time>0,"Night","Day"))

## Archetype formula
archetype_formula <- as.formula(paste0(paste0('cbind(',paste(colnames(samdat_10p)[grep("spp",colnames(samdat_10p))],collapse = ", "),") ~ poly(Temperature,degree=2,raw=TRUE)+poly(Oxygen,degree=2,raw=TRUE)+poly(Depth,degree=2,raw=TRUE)+poly(Productivity,degree=2,raw=TRUE)+Time")))

## Species formula
species_formula <- ~ 1

## Fit a single model
sam_fit <- species_mix(archetype_formula = archetype_formula, # Archetype formula
                       species_formula = species_formula,    # Species formula
                       data = samdat_10p,            # Data
                       nArchetypes = 3,              # Number of groups (mixtures) to fit
                       family = 'bernoulli',         # Which probability distribution to use
                       control = list(quiet = FALSE))
```

#### Model diagnostics and checking
Once we selected the 'best' model we can start to explore the model fit via diagnostics and checks. Typically, we would look at the model residuals to understand the model diagnostics [@warton_model-based_2015]. Here we present the random quantile residuals [@dunn_randomized_1996] versus the fitted values from the model (fig. 2b). We can see the residuals, presented on a species by species level, are approximately randomly distributed along the fitted line, which suggests nothing is untoward with the model fit.

We can also look at the parameter estimates from the model, because we simulated the data from known parameters it is easy to show that we can recapture these parameters (fig. 2c & 2d). To get credible intervals on the SAM parameters we can use a simulation approach via a Bayesian bootstrap to present variances in the parameter estimates. In Fig. 2c, we show the species intercepts ($\alpha_j$), these are the underling occurrence of each species, we can see the estimated values of $alpha_j$ are closely correlated with the true values. In Fig. 2b, we show the archetype specific covariates for each environmental covariate. 

We can also plot the partial responses of covariates as shown in @dunstan_model_2011 & @hui_mix_2013. The idea behind this approach is to understand the response of archetype or species to a focal predictor. First we need to set up a data.frame which allows the focal.predictor to vary and averages over the other effects in the model. We show how to do this in the next code chunk. We can include estimates of uncertainty in the partial response plots by including a bootstrap object into the plot function.

```{r partial plots, fig.width=6, fig.height=6}
par(mfrow=c(2,3))
eff.df <- effectPlotData(focal.predictors = c("Temperature","Oxygen","Productivity","Depth","Time"), sam_fit)
sam_boot <- species_mix.bootstrap(sam_fit,nboot = 10, quiet = TRUE)
plot(x = eff.df, object = sam_fit, object2=sam_boot,ylim=c(0,1))
```


#### Model prediction
We can generate model prediction for the each archetype in ecomix using `predict()` function. The default is used to generate a point mean estimate for each archetype. With the inclusion of a species mix bootstrap object generated from `species_mix.bootstrap` we can also provide estimates of uncertainty or standard error for each prediction. We can see spatial predict the point mean and standard error in the predicted distributions of each archetype (Fig. 3e & 3f). We can also see the spatial response of each archetype is strongly correlated to it's environmental response to each covariate (Fig. 2). For example, archetype two has a strong response to depth (Fig. 3e), which is evident in the archetype responses (Fig. 3d).

<!-- ```{r, echo = FALSE, eval=TRUE, message=FALSE, warning= FALSE} -->
<!-- resids.sam <- residuals(fms[[3]][[1]]) -->
<!-- colnames(resids.sam) <- paste0("spp",1:fms[[3]][[1]]$S) -->
<!-- sppID <- rep( TRUE, fms[[3]][[1]]$S) -->
<!-- preds <- predict(fms[[3]][[1]],prediction.type = "species") -->
<!-- link <- make.link("logit") -->
<!-- df <- data.frame(idx = 1:nrow(resids.sam),resids.sam) -->
<!-- dfm <- reshape2::melt(df,id.var='idx') -->
<!-- dfm$preds <- c(link$linkfun(preds)) -->
<!-- colnames(dfm) <- c("idx","Species","SAM","preds") -->
<!-- getPalette = colorRampPalette(RColorBrewer::brewer.pal(9, "Set1")) -->
<!-- colourCount = length(unique(dfm$Species)) -->

<!-- library(ggplot2) -->
<!-- p2b <- ggplot(dfm,aes(x=preds,y=SAM,colour=Species))+ -->
<!--       geom_point()+ -->
<!--       scale_color_manual(values = getPalette(colourCount))+ -->
<!--       xlab("Fitted values (logit scale)")+ -->
<!--       ylab("RQR")+ -->
<!--       ggtitle("b)")+ -->
<!--       theme(legend.position = "none") -->
<!-- ``` -->


<!-- ```{r,echo=FALSE,message=FALSE, warning= FALSE} -->
<!-- mod_spp <- length(fms[[3]][[1]]$alpha) -->
<!-- alphaBoot <- sam3_boot[,1:mod_spp] -->

<!-- set.seed(42) -->
<!-- df <- data.frame(x = rep(1:10,each=5), y = rnorm(50)) -->

<!-- library(ggplot2) -->
<!-- library(dplyr) -->
<!-- library(reshape2) -->
<!-- colnames(alphaBoot) <- fms[[3]][[1]]$names$spp -->
<!-- dfm <- melt(alphaBoot) -->
<!-- df.summary <- dfm %>% group_by(Var2) %>% -->
<!--     summarize(ylq = quantile(value,0.025), -->
<!--               yuq = quantile(value,0.975), -->
<!--               ymean = mean(value)) -->
<!-- df.summary$alpha_true <- alphas[-which(colSums(simulated_data200[,1:100])<10)] -->
<!-- p2c <- ggplot(df.summary, aes(x = alpha_true, y = ymean)) + -->
<!--         geom_point(size = 2,col='dodgerblue') + -->
<!--         geom_errorbar(aes(ymin = ylq, ymax = yuq),col='dodgerblue')+ -->
<!--         geom_abline(intercept=0,slope=1)+ -->
<!--         ylab("Estimated Alphas")+ -->
<!--         xlab("Known Alphas")+ -->
<!--         ggtitle("c)") -->

<!-- betaBoot <- sam3_boot[,-1:-mod_spp] -->
<!-- betaBoot <- betaBoot[,-13:-ncol(sam3_boot)] -->

<!-- colnames(betaBoot) <- paste0(substr(rep(fms[[3]][[1]]$names$Xvars,each=3), start = 1, stop = 2),".",c("A1","A2","A3")) -->

<!-- dfm <- melt(betaBoot) -->
<!-- df.summary2 <- dfm %>% group_by(Var2) %>% -->
<!--     summarize(ylq = quantile(value,0.025), -->
<!--               yuq = quantile(value,0.975), -->
<!--               ymean = mean(value)) -->
<!-- df.summary2$beta_true <- as.numeric(betas[c(2,3,1),]) -->
<!-- p2d <- ggplot(df.summary2, aes(x = forcats::fct_rev(Var2), y = ymean)) + -->
<!--         geom_point(size = 2,col='dodgerblue') + -->
<!--         geom_linerange(aes(ymin = ylq, ymax = yuq),col='dodgerblue')+ -->
<!--         geom_point(aes(x = Var2, y = beta_true),size = 2,col='tomato') + -->
<!--         coord_flip()+ -->
<!--         ylab("Beta value")+ -->
<!--         xlab("Name of Beta")+ -->
<!--         ggtitle("d)") -->
<!-- ``` -->

```{r archetype predictions,fig.width= 4, fig.height= 6,fig.cap="Figure 3. a) The predicted probability of each species archetype across the simulated environment; b) The standard error of the predictions generated using a Bayesian bootstrap from the model fit."}
library(ggplot2)
library(reshape2)
env.df$Time <- factor("Day",levels=c("Day","Night"))
sam3_pred <- ecomix:::predict.species_mix(sam_fit, sam_boot, newdata=env.df)

pred.df <- data.frame(x=env.df$x,y=env.df$y,sam3_pred$ptPreds)
pred.dfm <- melt(pred.df,id.vars = c("x","y"))

pred.dfse <- data.frame(x=env.df$x,y=env.df$y,sam3_pred$bootSEs)
pred.dfmse <- melt(pred.dfse,id.vars = c("x","y"))

p3a <- ggplot() +
  geom_raster(data =  pred.dfm,aes(x = x, y = y,fill=value)) +
  scale_fill_distiller(palette = "PuOr",direction = -1)+
  labs(fill="Pr")+
  # guide_legend(size = guide_legend(title.position="top", title.hjust = 0.5))+
  theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position="bottom",
        legend.box="horizontal",
        legend.key.size = unit(0.3, "cm"),
        legend.text = element_text(size=6),
       legend.title =  element_text(size=8)) +
  facet_grid(variable~.,switch = "y")+
  scale_x_continuous(expand=c(0, 0)) +
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('a)')+
  coord_fixed()

pinks <- colorRampPalette(c("white","lightpink","pink"))

p3b <- ggplot() +
  geom_raster(data =  pred.dfmse,aes(x = x, y = y,fill=value)) +
 scale_fill_gradientn(colours=pinks(4))+
 labs(fill="S.E")+
 theme(axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        # axis.text.x = element_text(angle = 30),
        panel.grid = element_blank(),
        legend.position = "bottom",
        legend.key.size = unit(0.3, "cm"),
        legend.text = element_text(size=6),
       legend.title =  element_text(size=8)) +
  facet_grid(variable~. ,switch = "y")+
  scale_x_continuous(expand=c(0, 0)) +
  scale_y_continuous(expand=c(0, 0))+
  ggtitle('b)')+
  coord_fixed()
grid.arrange(p3a, p3b, ncol=2)
```

<!-- ```{r archetype plots1, fig.width= 4, fig.height= 6, fig.cap="Figure 3. a) The count of species' occurrences within the simulated dataset, species with less that 10 occurrences across 200 sites are removed from the analysis; b) The estimated BIC values returned from the model fits, we can see three groups is the most parsomonious result; c)  The fitted versus known alphas (species intercepts); d) The fitted versus known species archetype specific parameters (betas); e) The predicted probability of each species archetype across the simulated environment; f) The standard error of the predictions generated using a Bayesian bootstrap from the model fit.", echo=FALSE} -->
<!-- library(gridExtra) -->
<!-- lay <- rbind(c(1,2,5,6), -->
<!--              c(3,4,5,6)) -->
<!-- grid.arrange(p2a,p2b, p2c, p2d,p2e, p2f,layout_matrix= lay) -->
<!-- ``` -->
